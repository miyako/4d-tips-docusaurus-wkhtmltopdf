<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html><html lang="de"><head><meta content="19 R5" name="docsearch:version" /><meta charset="utf-8" /><meta content="IE=edge" http-equiv="X-UA-Compatible" /><title>Interpretierter und kompilierter Modus · 4DDocumentation</title><meta content="width=device-width" name="viewport" /><meta content="Docusaurus" name="generator" /><meta content="4D Anwendungen können im **interpretierten** oder **kompilierten** Modus laufen:"name="description" /><meta content="de" name="docsearch:language" /><meta content="Interpretierter und kompilierter Modus · 4D Documentation"property="og:title" /><meta content="website" property="og:type" /><meta content="https://4d.github.io/docs/Rx/index.html" property="og:url" /><meta content="4D Anwendungen können im **interpretierten** oder **kompilierten** Modus laufen:"property="og:description" /><meta content="https://4d.github.io/docs/Rx/img/logohome.png"property="og:image" /><meta content="summary" name="twitter:card" /><meta content="https://4d.github.io/docs/Rx/img/logohome.png" name="twitter:image" /><link href="https://developer.4d.com/docs/Rx/img/4d.gif" rel="shortcut icon" /><link href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/routeros.min.css"rel="stylesheet" /><link href="https://developer.4d.com/docs/Rx/css/main.css" rel="stylesheet" /></head><body class="sideNavVisible separateOnPageNav"><div class="navPusher" style="padding-top:0px!important;"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="#interpreted.md" rel="noreferrer noopener" target="_blank">Edit</a><h1 class="postHeaderTitle" id="__docusaurus">Interpretierter undkompilierter Modus<a aria-hidden="true" class="anchor" id="interpreted-compiled.html"></a></h1></header><article><div><p><span>4D Anwendungen können im <strong>interpretierten</strong>oder <strong>kompilierten</strong> Modus laufen:</span></p><ul><li><span>Im interpretierten Modus werden Anweisungen im Moment derAusführung gelesen und in Maschinensprache übersetzt. Sie könnenden Code immer, wenn Sie es benötigen, ergänzen oder verändern, dieAnwendung wird automatisch aktualisiert.</span></li><li><span>Im kompilierten Modus werden alle Methoden während demKompilieren auf einmal gelesen und übersetzt. Das Ergebnis ist eineneue Datei mit einer Reihe von Anweisungen in Maschinensprache. DerCode lässt sich nicht mehr bearbeiten.</span></li></ul><p><span>Die Vorteile von Kompilieren sind:</span></p><ul><li><span><strong>Geschwindigkeit</strong>: Ihre Anwendung läuft umden Faktor von 3 bis 1000 mal schneller.</span></li><li><span><strong>Überprüfung des Code</strong>: Ihre Anwendungwird auf Übereinstimmung des Code geprüft. 4D Compiler findetsowohl logische als auch Syntaxfehler.</span></li><li><span><strong>Schutz</strong>: Ist Ihre Anwendung kompiliert,können Sie den interpretierten Code löschen. Denn die kompilierteAnwendung hat dieselben Funktionalitäten wie ihr Original. DerUnterschied ist, dass Sie die Struktur und Methoden weder ansehennoch verändern können, sei es gewollt oderversehentlich.</span></li><li><span><strong>Eigenständige, doppelklickbareAnwendungen</strong>; Kompilierte Anwendungen lassen sich ineigenständige Anwendungen (.EXE Dateien) mit ihren eigenen Iconsumwandeln.</span></li><li><span><strong>Preemptive Modus</strong>: Nur kompilierter Codelässt sich in preemptive Prozessen ausführen.</span></li></ul><h2><span><a aria-hidden="true" class="anchor" id="interpreted-compiled.html_unterschiede-zwischen-interpretiertem-und-kompiliertem-code"></a><a aria-hidden="true" class="hash-link" href="#interpreted-compiled.html_unterschiede-zwischen-interpretiertem-und-kompiliertem-code"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>Unterschiede zwischen interpretiertem und kompiliertemCode</span></h2><p><span>Auch wenn Anwendungen im interpretierten und kompiliertenModus auf die gleiche Weise funktionieren, gibt es einigeUnterschiede, die Sie kennen sollten, wenn Sie Code schreiben, derdann kompiliert wird. Der 4D Interpreter ist in der Regel flexiblerals der Compiler.</span></p><table><thead><tr><th>Kompiliert</th><th>Interpretiert</th></tr></thead><tbody><tr><td>Sie können keine Methode mit demselben Name wie eine Variablehaben.</td><td>Es wird kein Fehler generiert, jedoch erhält die MethodePriorität</td></tr><tr><td>Alle Variablen müssen typisiert sein, entweder über eineCompiler-Direktive (z. B. <code>C_LONGINT</code>) oder durch denCompiler beim Kompilieren.</td><td>Variablen lassen sich spontan typisieren (nicht empfohlen)</td></tr><tr><td>Sie können den Datentyp von Variablen oder Arrays nichtändern.</td><td>Der Datentyp einer Variablen oder eines Array lässt sichverändern (nicht empfohlen)</td></tr><tr><td>Sie können ein eindimensionales Array nicht in einzweidimensionales Array umwandeln und umgekehrt.</td><td>Ist möglich</td></tr><tr><td>Auch wenn der Compiler den Typ der Variablen für Sie festlegt,sollten Sie bei zweideutigen Datentypen, wie z. B. in einemFormular, den Datentyp der Variablen mit Compiler-Befehlendeklarieren.</td><td></td></tr><tr><td>Die Funktion <code>Undefined</code> gibt für Variablen immerden Wert Falsch zurück. Variablen sind immer definiert.</td><td></td></tr><tr><td>Ist für die Methode die Eigenschaft "Als preemptive Prozessstarten" markiert, darf der Code weder thread-unsafe Befehle oderandere thread-unsafe Methoden aufrufen.</td><td>Preemptive Prozesseigenschaften werden ignoriert</td></tr><tr><td>Der Befehl <code>IDLE</code> ist notwendig, um 4D inspezifischen Schleifen aufzurufen</td><td>Es ist immer möglich, 4D zu unterbrechen</td></tr></tbody></table><h2><span><a aria-hidden="true" class="anchor" id="interpreted-compiled.html_compiler-direktiven-mit-dem-interpreter-verwenden"></a><a aria-hidden="true" class="hash-link" href="#interpreted-compiled.html_compiler-direktiven-mit-dem-interpreter-verwenden"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>Compiler-Direktiven mit dem Interpreterverwenden</span></h2><p><span>Für nicht-kompilierte Anwendungen sind keine CompilerDirektiven erforderlich. Der Interpreter typisiert automatisch jedeVariable danach, wie sie in der Anweisung verwendet wird, und derVariablentyp lässt sich im Anwendungsprojekt freiverändern.</span></p><p><span>Aufgrund dieser Flexibilität kann eine Anwendung iminterpretierten Modus anders als im kompilierten Moduslaufen.</span></p><p><span>Sie schreiben zum Beispiel:</span></p><pre><span><code class="hljs css language-4d"><span class="hljs-function">C_LONGINT</span>(MyInt)</code></span></pre><p>und an anderer Stelle im Projekt:</p><pre><code class="hljs css language-4d">MyInt:=<span class="hljs-number">3.1416</span></code></pre><p>In diesem Beispiel wird <code>MyInt</code> im interpretiertenund kompilierten Modus derselbe Wert (3) zugewiesen, wenn dieCompiler-Direktive <em>vor</em> Ausführen der Anweisunginterpretiert wird.</p><p>Der 4D Interpreter verwendet Compiler-Direktiven zum Typisierender Variablen. Findet der Interpreter eine Compiler-Direktive,typisiert er die Variable gemäß dieser Direktive. Versucht einenachfolgende Anweisung, einen inkorrekten Wert zuzuweisen (z.B.einer numerischen Variablen einen alphanumerischen Wert), erfolgtkeine Zuweisung und es wird ein Fehler generiert.</p><p>Die Reihenfolge, in der zwei Anweisungen erscheinen, ist für denCompiler irrelevant, da er zuerst das gesamte Projekt für CompilerDirektiven scannt. Der Interpreter ist dagegen nicht systematisch.Er interpretiert Anweisungen der Reihe nach. Diese Reihenfolge kannnatürlich von Sitzung zu Sitzung anders sein, je nachdem was derBenutzer macht. Aus diesem Grund ist es wichtig, dass Sie IhrProjekt so gestalten, dass Ihre Compiler-Direktiven vor jeglicherAnweisung mit deklarierten Variablen ausgeführt werden.</p><h2><a aria-hidden="true" class="anchor" id="interpreted-compiled.html_mit-zeigern-erneute-typisierung-vermeiden"></a><a aria-hidden="true" class="hash-link" href="#interpreted-compiled.html_mit-zeigern-erneute-typisierung-vermeiden"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>Mit Zeigern erneute Typisierung vermeiden</h2><p>Eine Variable kann nicht erneut typisiert werden. Sie könnenjedoch einen Zeiger verwenden, um auf Variablen mitunterschiedlichen Datentypen zu verweisen. Zum Beispiel istfolgender Code sowohl im interpretierten als auch im kompiliertenModus erlaubt:</p><pre><code class="hljs css language-4d"><span class="hljs-function">C_POINTER</span>(<span class="hljs-variable">$p</span>)<span class="hljs-function">C_TEXT</span>(<span class="hljs-variable">$name</span>)<span class="hljs-function">C_LONGINT</span>(<span class="hljs-variable">$age</span>)<span class="hljs-variable">$name</span>:=<span class="hljs-string">"Smith"</span><span class="hljs-variable">$age</span>:=<span class="hljs-number">50</span><span class="hljs-variable">$p</span>:=-&gt;<span class="hljs-variable">$name </span><span class="hljs-comment">//text target for the pointer</span><span class="hljs-variable">$p</span>-&gt;:=<span class="hljs-string">"Wesson"</span> <span class="hljs-comment">//assigns a text value</span><span class="hljs-variable">$p</span>:=-&gt;<span class="hljs-variable">$age  </span><span class="hljs-comment">// new target of different type for the pointer</span><span class="hljs-variable">$p</span>-&gt;:=<span class="hljs-number">55</span> <span class="hljs-comment">//assigns a number value</span></code></pre><p>Stellen Sie sich eine Funktion vor, welche die Länge (AnzahlZeichen) von Werten zurückgibt, die von beliebigem Typ seinkönnen.</p><pre><code class="hljs css language-4d">  <span class="hljs-comment">// Calc_Length (how many characters)</span>  <span class="hljs-comment">// $1 = pointer to flexible variable type, numeric, text, time, boolean</span><span class="hljs-function">C_POINTER</span>(<span class="hljs-variable">$1</span>)<span class="hljs-function">C_TEXT</span>(<span class="hljs-variable">$result</span>)  <span class="hljs-function">C_LONGINT</span>(<span class="hljs-variable">$0</span>)<span class="hljs-variable">$result</span>:=<span class="hljs-function">String</span>(<span class="hljs-variable">$1</span>-&gt;)<span class="hljs-variable">$0</span>:=<span class="hljs-function">Length</span>(<span class="hljs-variable">$result</span>)</code></pre><p>Dann lässt sich diese Methode aufrufen:</p><pre><code class="hljs css language-4d"><span class="hljs-variable">$var1</span>:=<span class="hljs-string">"my text"</span><span class="hljs-variable">$var2</span>:=<span class="hljs-number">5.3</span><span class="hljs-variable">$var3</span>:=<span class="hljs-literal">?10:02:24?</span><span class="hljs-variable">$var4</span>:=<span class="hljs-literal">True</span><span class="hljs-variable">$vLength</span>:=<span class="hljs-function">Calc_Length</span>(-&gt;<span class="hljs-variable">$var1</span>)+<span class="hljs-function">Calc_Length</span>(-&gt;<span class="hljs-variable">$var2</span>)+<span class="hljs-function">Calc_Length </span>(-&gt;<span class="hljs-variable">$var3</span>)+<span class="hljs-function">Calc_Length</span>(-&gt;<span class="hljs-variable">$var4</span>)<span class="hljs-function">ALERT</span>(<span class="hljs-string">"Total length: "</span>+<span class="hljs-function">String</span>(<span class="hljs-variable">$vLength</span>))</code></pre></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="#error-handling.html"><span class="arrow-prev">←</span><span>Fehlerverwaltung</span></a><a class="docs-next button" href="#components.html"><span>Komponenten</span> <span class="arrow-next">→</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#interpreted-compiled.html_unterschiede-zwischen-interpretiertem-und-kompiliertem-code">Unterschiede zwischen interpretiertem und kompiliertemCode</a></li><li><a href="#interpreted-compiled.html_compiler-direktiven-mit-dem-interpreter-verwenden">Compiler-Direktiven mit dem Interpreter verwenden</a></li><li><a href="#interpreted-compiled.html_mit-zeigern-erneute-typisierung-vermeiden">Mit Zeigern erneute Typisierung vermeiden</a></li></ul></nav></div></div></body></html>