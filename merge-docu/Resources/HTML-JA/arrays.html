<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html><html lang="ja"><head><meta content="19 R5" name="docsearch:version" /><meta charset="utf-8" /><meta content="IE=edge" http-equiv="X-UA-Compatible" /><title>配列 · 4D Documentation</title><meta content="width=device-width" name="viewport" /><meta content="Docusaurus" name="generator" /><meta content="**配列** とは、同じタイプの **変数** を番号付きで並べたものです。 各変数は、配列の **要素** といいます。 配列のサイズとは、配列が持つ要素の数を指します。配列は作成時にサイズが与えられ、要素の追加・挿入・削除によって、または作成時に使用したコマンドの再使用によって、何度でもサイズを変更することができます。 配列要素には、1 から N の番号が付けられます (N は配列のサイズ)。 配列は必ず、特別な [要素ゼロ](#配列の要素ゼロ) を持ちます。 配列は 4D の変数です。 他の変数と同様、配列にもスコープがあり、4D ランゲージの規則に従いますが、他と異なるところがいくつかあります。"name="description" /><meta content="ja" name="docsearch:language" /><meta content="配列 · 4D Documentation" property="og:title" /><meta content="website" property="og:type" /><meta content="https://4d.github.io/docs/Rx/index.html" property="og:url" /><meta content="**配列** とは、同じタイプの **変数** を番号付きで並べたものです。 各変数は、配列の **要素** といいます。 配列のサイズとは、配列が持つ要素の数を指します。配列は作成時にサイズが与えられ、要素の追加・挿入・削除によって、または作成時に使用したコマンドの再使用によって、何度でもサイズを変更することができます。 配列要素には、1 から N の番号が付けられます (N は配列のサイズ)。 配列は必ず、特別な [要素ゼロ](#配列の要素ゼロ) を持ちます。 配列は 4D の変数です。 他の変数と同様、配列にもスコープがあり、4D ランゲージの規則に従いますが、他と異なるところがいくつかあります。"property="og:description" /><meta content="https://4d.github.io/docs/Rx/img/logohome.png"property="og:image" /><meta content="summary" name="twitter:card" /><meta content="https://4d.github.io/docs/Rx/img/logohome.png" name="twitter:image" /><link href="https://developer.4d.com/docs/Rx/img/4d.gif" rel="shortcut icon" /><link href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/routeros.min.css"rel="stylesheet" /><link href="https://developer.4d.com/docs/Rx/css/main.css" rel="stylesheet" /></head><body class="sideNavVisible separateOnPageNav"><div class="navPusher" style="padding-top:0px!important;"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="#arrays.md" rel="noreferrer noopener" target="_blank">Edit</a><h1 class="postHeaderTitle" id="__docusaurus">配列<a aria-hidden="true" class="anchor" id="arrays.html"></a></h1></header><article><div><p><span><strong>配列</strong> とは、同じタイプの <strong>変数</strong>を番号付きで並べたものです。 各変数は、配列の <strong>要素</strong> といいます。配列のサイズとは、配列が持つ要素の数を指します。配列は作成時にサイズが与えられ、要素の追加・挿入・削除によって、または作成時に使用したコマンドの再使用によって、何度でもサイズを変更することができます。配列要素には、1 から N の番号が付けられます (N は配列のサイズ)。 配列は必ず、特別な <a href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25AE%25E8%25A6%2581%25E7%25B4%25A0%25E3%2582%25BC%25E3%2583%25AD">要素ゼロ</a> を持ちます。 配列は 4D の変数です。 他の変数と同様、配列にもスコープがあり、4Dランゲージの規則に従いますが、他と異なるところがいくつかあります。</span></p><blockquote><p><span>ほとんどの場合において、<strong>配列</strong> より <strong>コレクション</strong>の利用が推奨されます。 コレクションは配列より柔軟なだけでなく、たくさんの専用メソッドを持ちます。 詳細については、<a href="#collection.html">コレクション</a> を参照してください。</span></p></blockquote><h2><span><a aria-hidden="true" class="anchor" id="arrays.html_%E9%85%8D%E5%88%97%E3%81%AE%E4%BD%9C%E6%88%90"></a><a aria-hidden="true"class="hash-link" href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25AE%25E4%25BD%259C%25E6%2588%2590"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>配列の作成</span></h2><p><span>配列は、"配列" テーマの配列宣言コマンドのいずれかを使用して作成します。 配列宣言コマンドは、1次元または2次元の配列の作成やサイズ変更をすることができます。 2次元配列の詳細については <a href="#arrays.html_%25E4%25BA%258C%25E6%25AC%25A1%25E5%2585%2583%25E9%2585%258D%25E5%2588%2597">二次元配列</a> を参照してください。</span></p><p><span>次のコードは、10個の要素からなる整数配列を作成 (宣言) します:</span></p><pre><span><code class="hljs css language-4d"><span class="hljs-function"> ARRAY INTEGER</span>(aiAnArray;<span class="hljs-number">10</span>)</code></span></pre><p>次のコードは、さきほど作成した配列を20要素にサイズ変更します:</p><pre><code class="hljs css language-4d"><span class="hljs-function">ARRAY INTEGER</span>(aiAnArray;<span class="hljs-number">20</span>)</code></pre><p>次のコードは、この配列を要素なしにサイズ変更します:</p><pre><code class="hljs css language-4d"><span class="hljs-function">ARRAY INTEGER</span>(aiAnArray;<span class="hljs-number">0</span>)</code></pre><h2><a aria-hidden="true" class="anchor" id="arrays.html_%E9%85%8D%E5%88%97%E8%A6%81%E7%B4%A0%E3%81%B8%E3%81%AE%E5%80%A4%E3%81%AE%E4%BB%A3%E5%85%A5"></a><a aria-hidden="true" class="hash-link" href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E8%25A6%2581%25E7%25B4%25A0%25E3%2581%25B8%25E3%2581%25AE%25E5%2580%25A4%25E3%2581%25AE%25E4%25BB%25A3%25E5%2585%25A5"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>配列要素への値の代入</h2><p>配列中の要素は中カッコ ({…}) を使用して参照します。中カッコの中には数字を入れて特定の要素を指定します。この数字を要素番号といいます。 次のコードは、5つの名前を atNamesという配列に入れ、それらを警告ウィンドウに表示します:</p><pre><code class="hljs css language-4d"><span class="hljs-function"> ARRAY TEXT</span>(atNames;<span class="hljs-number">5</span>) atNames{<span class="hljs-number">1</span>}:=<span class="hljs-string">"Richard"</span> atNames{<span class="hljs-number">2</span>}:=<span class="hljs-string">"Sarah"</span> atNames{<span class="hljs-number">3</span>}:=<span class="hljs-string">"Sam"</span> atNames{<span class="hljs-number">4</span>}:=<span class="hljs-string">"Jane"</span> atNames{<span class="hljs-number">5</span>}:=<span class="hljs-string">"John"</span><span class="hljs-keyword"> For</span>(<span class="hljs-variable">$vlElem</span>;<span class="hljs-number">1</span>;<span class="hljs-number">5</span>)<span class="hljs-function">    ALERT</span>(<span class="hljs-string">"要素番号 #"</span>+<span class="hljs-function">String</span>(<span class="hljs-variable">$vlElem</span>)+<span class="hljs-string">" の値は "</span>+atNames{<span class="hljs-variable">$vlElem}</span>+<span class="hljs-string">" です。"</span>)<span class="hljs-keyword"> End for</span></code></pre><p>atNames{$vlElem} というシンタックスに注目してください。 atNames{3}のように数値リテラルを使うだけでなく、数値変数によって配列の要素番号を指定することができます。 ループ構造による反復を使用すると(<code>For...End for</code>, <code>Repeat...Until</code> または<code>While...Endwhile</code>)、短いコードで配列の全要素、または一部の要素を対象とした処理をおこなうことができます。</p><p><strong>重要:</strong> 代入演算子 (:=) と比較演算子 (=) とを混同しないように注意してください。代入と比較は、まったく異なった性質の処理です。</p><h3><a aria-hidden="true" class="anchor" id="arrays.html_%E9%85%8D%E5%88%97%E3%81%B8%E3%81%AE%E9%85%8D%E5%88%97%E3%81%AE%E4%BB%A3%E5%85%A5"></a><a aria-hidden="true" class="hash-link" href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25B8%25E3%2581%25AE%25E9%2585%258D%25E5%2588%2597%25E3%2581%25AE%25E4%25BB%25A3%25E5%2585%25A5"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>配列への配列の代入</h3><p>文字列やテキスト変数と違って、配列に配列を代入することはできません。 配列をそっくりそのまま別の配列にコピーするには<code>COPY ARRAY</code> コマンドを使います。</p><h2><a aria-hidden="true" class="anchor" id="arrays.html_%E9%85%8D%E5%88%97%E3%81%AE%E8%A6%81%E7%B4%A0%E3%82%BC%E3%83%AD"></a><a aria-hidden="true" class="hash-link" href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25AE%25E8%25A6%2581%25E7%25B4%25A0%25E3%2582%25BC%25E3%2583%25AD"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>配列の要素ゼロ</h2><p>配列は必ず、要素ゼロを持ちます。ドロップダウンリストなどのフォームオブジェクトに配列が設定されていた場合、要素ゼロが表示されることはありませんが、ランゲージでの利用に制限はありません(*)。</p><p>例として、デフォルト値を指定せずにフォームオブジェクトを初期化したいとします。このような場合に配列の要素ゼロが利用できます:</p><pre><code class="hljs css language-4d">  // atName 配列と紐づいているコンボボックスまたはドロップダウンリストの   // フォームオブジェクトメソッドです Case of    :(Form event code=On Load)  // 要素ゼロを含め  // 配列を初期化します        ARRAY TEXT(atName;5)        atName{0}:=選択してください"        atName{1}:="Text1"        atName{2}:="Text2"        atName{3}:="Text3"        atName{4}:="Text4"        atName{5}:="Text5"    // 配列の選択要素を要素ゼロに設定します        atName:=0 End case</code></pre><p>(*)ひとつだけ例外があります。配列タイプのリストボックスでは、編集中の元の値を保持するため、内部的に配列の要素ゼロが使用されます。この特別なケースでは、開発者は0番目の要素を利用できません。</p><h2><a aria-hidden="true" class="anchor" id="arrays.html_%E4%BA%8C%E6%AC%A1%E5%85%83%E9%85%8D%E5%88%97"></a><a aria-hidden="true"class="hash-link" href="#arrays.html_%25E4%25BA%258C%25E6%25AC%25A1%25E5%2585%2583%25E9%2585%258D%25E5%2588%2597"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>二次元配列</h2><p>配列宣言コマンドはそれぞれ、1次元および 2次元の配列を作成、またはサイズ変更ができます。 例:</p><pre><code class="hljs css language-4d"><span class="hljs-function"> ARRAY TEXT</span>(atTopics;<span class="hljs-number">100</span>;<span class="hljs-number">50</span>) <span class="hljs-comment">// 100行と 50列からなるテキスト配列を作成します</span></code></pre><p>2次元配列は、本質的にはランゲージオブジェクトであり、表示や印刷することはできません。</p><p>上のコードで作成した atTopics 配列について、次のことが言えます:</p><ul><li>atTopics は、2次元配列です。</li><li>atTopics{8}{5} は、8行5列目の要素です。</li><li>atTopics{20} は 20行目を指し、それ自体が 1次元の配列です。</li><li><code>Size of array(atTopics)</code> は、行数の 100を返します。</li><li><code>Size of array(atTopics{17})</code>は、17行目の列数である50を返します。</li></ul><p>以下の例では、データベースの各テーブルの各フィールドへのポインターが 2次元配列に格納されます:</p><pre><code class="hljs css language-4d"><span class="hljs-function"> C_LONGINT</span>(<span class="hljs-variable">$vlLastTable</span>;<span class="hljs-variable">$vlLastField</span>)<span class="hljs-function"> C_LONGINT</span>(<span class="hljs-variable">$vlFieldNumber</span>)  <span class="hljs-comment">// テーブルと同じ数の空行 (つまり、列なし) を持つ配列作成します</span> <span class="hljs-variable">$vlLastTable</span>:=Get last table number<span class="hljs-function"> ARRAY POINTER</span>(<span class="hljs-variable">&lt;&gt;apFields</span>;<span class="hljs-variable">$vlLastTable</span>;<span class="hljs-number">0</span>) <span class="hljs-comment">// X行 0列の 2D配列</span>  <span class="hljs-comment">// テーブル毎に</span><span class="hljs-keyword"> For</span>(<span class="hljs-variable">$vlTable</span>;<span class="hljs-number">1</span>;<span class="hljs-variable">$vlLastTable</span>)<span class="hljs-keyword">    If</span>(<span class="hljs-function">Is table number valid</span>(<span class="hljs-variable">$vlTable</span>))       <span class="hljs-variable">$vlLastField</span>:=<span class="hljs-function">Get last field number</span>(<span class="hljs-variable">$vlTable</span>)  <span class="hljs-comment">// 全フィールドをチェックします</span>       <span class="hljs-variable">$vlColumnNumber</span>:=<span class="hljs-number">0</span><span class="hljs-keyword">       For</span>(<span class="hljs-variable">$vlField</span>;<span class="hljs-number">1</span>;<span class="hljs-variable">$vlLastField</span>)<span class="hljs-keyword">          If</span>(<span class="hljs-function">Is field number valid</span>(<span class="hljs-variable">$vlTable</span>;<span class="hljs-variable">$vlField</span>))             <span class="hljs-variable">$vlColumnNumber</span>:=<span class="hljs-variable">$vlColumnNumber</span>+<span class="hljs-number">1</span>  <span class="hljs-comment">// 当該テーブルの行にフィールドに対応する列を挿入していきます</span><span class="hljs-function">             INSERT IN ARRAY</span>(<span class="hljs-variable">&lt;&gt;apFields{</span><span class="hljs-variable">$vlTable}</span>;<span class="hljs-variable">$vlColumnNumber</span>;<span class="hljs-number">1</span>)  <span class="hljs-comment">// 作成した "セル" にポインターを割り当てます</span>             <span class="hljs-variable">&lt;&gt;apFields{</span><span class="hljs-variable">$vlTable}{</span><span class="hljs-variable">$vlColumnNumber}</span>:=<span class="hljs-function">Field</span>(<span class="hljs-variable">$vlTable</span>;<span class="hljs-variable">$vlField</span>)<span class="hljs-keyword">          End if</span><span class="hljs-keyword">       End for</span><span class="hljs-keyword">    End if</span><span class="hljs-keyword"> End for</span></code></pre><p>このように初期化された 2次元配列を使って、以下の方法で特定のテーブルが持つ全フィールドへのポインターを取得できます:</p><pre><code class="hljs css language-4d">  <span class="hljs-comment">// 現在選択されているテーブルの、フィールドへのポインターを取得します:</span><span class="hljs-function"> COPY ARRAY</span>(<span class="hljs-function">◊apFields{Table</span>(Current form table)};<span class="hljs-variable">$apTheFieldsIamWorkingOn</span>)  <span class="hljs-comment">// ブールと日付フィールドを初期化します</span><span class="hljs-keyword"> For</span>(<span class="hljs-variable">$vlElem</span>;<span class="hljs-number">1</span>;<span class="hljs-function">Size of array</span>(<span class="hljs-variable">$apTheFieldsIamWorkingOn</span>))<span class="hljs-keyword">    Case of</span>       :(<span class="hljs-function">Type</span>(<span class="hljs-variable">$apTheFieldsIamWorkingOn{</span><span class="hljs-variable">$vlElem}</span>-&gt;)=Is date)          <span class="hljs-variable">$apTheFieldsIamWorkingOn{</span><span class="hljs-variable">$vlElem}</span>-&gt;:=Current date       :(<span class="hljs-function">Type</span>(<span class="hljs-variable">$apTheFieldsIamWorkingOn{</span><span class="hljs-variable">$vlElem}</span>-&gt;)=Is Boolean)          <span class="hljs-variable">$apTheFieldsIamWorkingOn{</span><span class="hljs-variable">$vlElem}</span>-&gt;:=<span class="hljs-literal">True</span><span class="hljs-keyword">    End case</span><span class="hljs-keyword"> End for</span></code></pre><p><strong>注:</strong>この例でわかるように、2次元配列の行の列数はそれぞれが同じサイズでも異なるサイズでも構いません。</p><h2><a aria-hidden="true" class="anchor" id="arrays.html_%E9%85%8D%E5%88%97%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA"></a><a aria-hidden="true" class="hash-link" href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25A8%25E3%2583%25A1%25E3%2583%25A2%25E3%2583%25AA"><svg aria-hidden="true"class="hash-link-icon" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"fill-rule="evenodd"></path></svg></a>配列とメモリ</h2><p>テーブルやレコードを使用してディスク上に格納するデータと異なり、配列は常に全体がメモリに保持されます。</p><p>たとえば、米国内の郵便番号がすべて [Zip Codes]テーブルに入力されている場合、約100,000件のレコードになります。加えて、そのテーブルには郵便番号のほかに、対応する市・郡・州という複数のフィールドがあるとします。カリフォルニアの郵便番号を選択した場合、4D データベースエンジンは [Zip Codes]テーブルから該当するレコードセレクションを作成して、必要な場合にのみ各レコードをロードします (たとえば表示や印刷時)。つまり、4Dのデータベースエンジンによってディスクからメモリに部分的にロードされた (フィールドごとに同じタイプの)順序づけられた一連の値で作業するということです。</p><p>同じことを配列で実行するのは、次の理由で禁止すべきです:</p><ul><li>4つの情報タイプ (郵便番号、市、郡、州) を維持するためには、4つの大きな配列をメモリ内で維持する必要があります。</li><li>配列は、常に全体がメモリ内に維持されるため、常時使用しない場合でも、作業セッションの間すべてのデータをメモリに置いておく必要があります。</li><li>配列全体が常にメモリ内に維持されることから、アプリケーションが開始されるたびに4つの配列をディスクからロードして、終了時にはディスクに保存する必要があります。当該データが作業セッション中に使用・変更されない場合もこれを省略することができません。</li></ul><p><strong>結論:</strong> 配列は、ほどよい量のデータを短時間維持するためのものです。他方、配列はメモリ内に置かれるため、扱いやすく高速操作が可能です。</p><p>しかし、状況によっては何百、何千という要素を持った配列で作業する必要があります。次の表に、各配列タイプがメモリ上に占めるバイト数を求めるための計算式を示します:</p><table><thead><tr><th>配列タイプ</th><th>メモリ使用量の計算式 (バイト単位)</th></tr></thead><tbody><tr><td>BLOB</td><td>(1+要素数) * 12 + 全BLOB要素の合計サイズ</td></tr><tr><td>ブール</td><td>(31+要素数) \ 8</td></tr><tr><td>日付</td><td>(1+要素数) * 6</td></tr><tr><td>整数</td><td>(1+要素数) * 2</td></tr><tr><td>倍長整数</td><td>(1+要素数) * 4</td></tr><tr><td>オブジェクト</td><td>(1+要素数) * 8 + 全オブジェクトの合計サイズ</td></tr><tr><td>ピクチャー</td><td>(1+要素数) * 8 + 全ピクチャーの合計サイズ</td></tr><tr><td>ポインター</td><td>(1+要素数) * 8 + 全ポインターの合計サイズ</td></tr><tr><td>実数</td><td>(1+要素数) * 8</td></tr><tr><td>テキスト</td><td>(1+要素数) * 20 + (全テキストの合計サイズ) * 2</td></tr><tr><td>時間</td><td>(1+要素数) * 4</td></tr><tr><td>2次元</td><td>(1+要素数) * 16 + 配列サイズの合計</td></tr></tbody></table><p><strong>注:</strong></p><ul><li>メモリ中のテキストサイズは以下の式で計算されます: ((Length + 1) * 2)</li><li>選択した要素や要素数、配列自体の情報を保持するため、さらに数バイトを要します。</li></ul></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="#variables.html"><span class="arrow-prev">←</span><span>変数</span></a><a class="docs-next button" href="#methods.html"><span>メソッド</span> <span class="arrow-next">→</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25AE%25E4%25BD%259C%25E6%2588%2590">配列の作成</a></li><li><a href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E8%25A6%2581%25E7%25B4%25A0%25E3%2581%25B8%25E3%2581%25AE%25E5%2580%25A4%25E3%2581%25AE%25E4%25BB%25A3%25E5%2585%25A5">配列要素への値の代入</a><ul class="toc-headings"><li><a href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25B8%25E3%2581%25AE%25E9%2585%258D%25E5%2588%2597%25E3%2581%25AE%25E4%25BB%25A3%25E5%2585%25A5">配列への配列の代入</a></li></ul></li><li><a href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25AE%25E8%25A6%2581%25E7%25B4%25A0%25E3%2582%25BC%25E3%2583%25AD">配列の要素ゼロ</a></li><li><a href="#arrays.html_%25E4%25BA%258C%25E6%25AC%25A1%25E5%2585%2583%25E9%2585%258D%25E5%2588%2597">二次元配列</a></li><li><a href="#arrays.html_%25E9%2585%258D%25E5%2588%2597%25E3%2581%25A8%25E3%2583%25A1%25E3%2583%25A2%25E3%2583%25AA">配列とメモリ</a></li></ul></nav></div></div></body></html>